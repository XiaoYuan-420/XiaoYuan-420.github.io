[{"content":"Python基础知识 学前提醒 一定记得要自己动手编程试试哦~\nPython简介 语言特点:面向对象、解释型、高级计算机程序设计语言 ①面向对象：使用函数与类(在后面拓展中有讲)的方式编程解决问题 ②解释型：在运行时，首先要将每条语句进行检查编译成机器语言(即0与1)再进行自顶而下的运行 ③优缺点:编写容易但运行速度较慢 Python Shell：交互式解释器,输入一条执行一条,输入的语句不会被保存 编辑器：输入的语句不会立刻被执行，编写完成保存并运行时才会被执行 历史(课外阅读):Python从诞生至今经历了一次大的更新换代,即Python2到Python3的飞跃。由于Python2功能的不完善,运行速度慢，维护困难等缺点，Python的创始人在C语言的基础上重新设计了Python3,与原先Python2在语法上有较大的差异，而原先的Python 2也渐渐淡出了历史舞台.我们学习的也都是Python3的语法. 目前较稳定的Python版本:Python 3.8,Python3.9,Python3.10,Python3.12 笔者的环境是Python3.12.0 输入与输出语句 输入语句：input() 在括号内可以输入提示语 注意通过input()得到的是字符串 1 a = input(\u0026#34;请输入一串字符：\u0026#34;) # 输入123456 输出语句：print() 括号内可以传入多个要输出的值 注意：当出现运算符＋时，请一定当心加号两边的数据类型是否一致，该如何转化 1 print(a, type(a)) # type()用来查看a的数据类型 123456 \u0026lt;class 'str'\u0026gt; 数据类型 1 2 3 num1 = 123 # int类型 十进制 num2 = 0b100101 # int类型 二进制 num3 = 0x1a2b3c # int类型 十六进制 1 2 float1 = 1.0 # float类型 float2 = 1e5 # float类型 科学计数法 相当于 1.0*10^5 1 2 3 str1 = \u0026#34;I\u0026#39;m Li Hua\u0026#34; # str类型 由双引号引导 str2 = \u0026#39;He said:\u0026#34;I am not good.\u0026#34;\u0026#39; # str类型 由单引号引导 str3 = \u0026#39;\u0026#39;\u0026#39;That\u0026#39;s a desk\u0026#39;\u0026#39;\u0026#39; # str类型 由三引号引导 1 2 bool1 = True # bool类型 真值 bool2 = False # bool类型 假值 运算符与表达式 表达式:由数字、运算符、数字分组符号、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合 运算符: 算术运算符\n注:若C=a%b, 当b\u0026gt;0时C∈[0,b) 当b\u0026lt;0时C∈(b,0]\n关系运算符\n注:链式比较 a\u0026lt;=b\u0026lt;=c ⇔ a\u0026lt;=b and b\u0026lt;=c\n逻辑运算符\n注:if not flag: ⇔ if flag==False:\n数据结构：（也是数据类型） 字符串（关于转义字符可转到“关于格式化输出”） 索引：从零开始的标号 索引取值 切片：格式：s[start:end:step] 1 2 3 4 5 6 7 8 9 s = \u0026#34;Hello,World\u0026#34; print(s[1]) try: print(s[11]) # 超出索引取值会报错 IndexError: string index out of range except IndexError as e: print(e) # 切片 s = \u0026#34;Hello,World\u0026#34; print(s[1:5]) e string index out of range ello 速会切片： 提示：若为负索引，将其加 len(s) 变为正索引 小技巧：\n①判断是否为空切片： 判断 (end-start) /step 是否大于 0(\u0026lt; 0为空)\n②切片中的元素个数（可用来检查）n=(end-start)//step\n列表 索引、切片与字符串相同 列表方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 l = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] print(f\u0026#34;{l=}\u0026#34;) l.append(\u0026#34;D\u0026#34;) # 向列表末尾插入一位元素 print(f\u0026#34;{l=}\u0026#34;) l.insert(4, \u0026#34;E\u0026#34;) # 插入，第一个参数为索引，第二个参数为元素 print(f\u0026#34;{l=}\u0026#34;) # 超过列表长度会被加入到列表末尾,现在列表长度为5 l.insert(10, \u0026#34;F\u0026#34;) print(f\u0026#34;{l=}\u0026#34;) del_val = l.pop() # 当pop中不传入任何参数时，默认删除最后一个元素 print(f\u0026#34;{l=}, {del_val=}\u0026#34;) del_val = l.pop(3) # 删除指定索引上的元素，会返回被删除的元素 print(f\u0026#34;{l=}, {del_val=}\u0026#34;) l.remove(\u0026#34;E\u0026#34;) # 删除指定元素，若存在多个，删除第一个出现的该元素 # remove没有返回值 print(f\u0026#34;{l=}\u0026#34;) l=['A', 'B', 'C'] l=['A', 'B', 'C', 'D'] l=['A', 'B', 'C', 'D', 'E'] l=['A', 'B', 'C', 'D', 'E', 'F'] l=['A', 'B', 'C', 'D', 'E'], del_val='F' l=['A', 'B', 'C', 'E'], del_val='D' l=['A', 'B', 'C'] 字典（也叫哈希表(Hash Table)）\n键-值对(可以有相同的值)： {key1:valuel, key2:value2,\u0026hellip;}\n键：可以是字符串、元组、整型、浮点型 不能是列表、字典(它们是unhashable,不能被哈希化的) 值：可以是任何类型 取值：\u0026lt;字典名\u0026gt;[\u0026lt;键名\u0026gt;]\n键名不在字典中会引发KeyError 字典方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 d = {\u0026#34;A\u0026#34;: 10, \u0026#34;B\u0026#34;: 11, \u0026#34;C\u0026#34;:12} print(d.keys()) # 返回Keys对象,可迭代 print(\u0026#34;---------\u0026#34;) for key in d.keys(): print(key) print(\u0026#34;---------\u0026#34;) print(d.values()) # 返回Values对象,可迭代 print(\u0026#34;---------\u0026#34;) for val in d.values(): print(val) print(\u0026#34;---------\u0026#34;) print(d.items()) # 返回Items对象,可迭代 print(\u0026#34;---------\u0026#34;) for key, val in d.items(): print(key, val) print(\u0026#34;---------\u0026#34;) s = \u0026#34;1A\u0026#34; for i in s: # get方法，若键名不在字典中，返回第二个参数 print(d.get(i, int(i, 16))) dict_keys(['A', 'B', 'C']) --------- A B C --------- dict_values([10, 11, 12]) --------- 10 11 12 --------- dict_items([('A', 10), ('B', 11), ('C', 12)]) --------- A 10 B 11 C 12 --------- 1 10 算法结构 顺序结构 1 2 3 4 a = 1 a = 2 a = 3 print(f\u0026#34;{a=}\u0026#34;) a=3 分支结构(if语句)：\n所有的分支结构只会运行至多1个(可能不运行)\n循环结构：(for语句与while语句)\nwhile语句中注意循环控制变量的值一定要有初值且一定在循环中被改变 while True循环一定有break语句(该情况下True就是True,不能是等于True的其它变量) break语句:结束当前整个循环 continue语句:进入下一趟循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 for i in range(1, 3): if i == 2: break for j in range(1, 5): print((i,j), end=\u0026#34;\\t\u0026#34;) print() print(\u0026#34;---------\u0026#34;) for i in range(1, 5): for j in range(1, 11): if j == 2: break print((i,j), end=\u0026#34;\\t\u0026#34;) print() print(\u0026#34;---------\u0026#34;) for i in range(1, 4): if i == 2: continue for j in range(1, 3): print((i,j), end=\u0026#34;\\t\u0026#34;) print() print(\u0026#34;---------\u0026#34;) for i in range(1, 4): for j in range(1, 3): if j == 2: continue print((i,j), end=\u0026#34;\\t\u0026#34;) (1, 1)\t(1, 2)\t(1, 3)\t(1, 4)\t--------- (1, 1)\t(2, 1)\t(3, 1)\t(4, 1)\t--------- (1, 1)\t(1, 2)\t(3, 1)\t(3, 2)\t--------- (1, 1)\t(2, 1)\t(3, 1)\t","date":"2024-09-30T11:12:41+08:00","permalink":"https://XiaoYuan-420.gituhub.io/p/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"Python基础知识"},{"content":"TSCTF-J XiaoYuan Writeup MISC set set password 单个数字之和必须等于 25，拿 1凑 罗马数字的乘积必须为 35，直接输 XXXV 验证码尽量刷出不含罗马数字和数字之和较小的 元素符号的拿 H凑 图寻直接一个国家一个国家试 密码长度拿空格凑和0凑（刚好满足闰年） 把系统时间设置成0:00避免25的问题 讲究一个暴力解决，说啥做啥，设置好密码就OK\nwordle 要赢100局肯定要找一个必胜策略，在开局的时候要尽可能的选择字母种数多的，而且字母的出现频率要高，可以排除更多的单词或确定更多的信息\n直接贴源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 import socket import random import json import time from collections import Counter with open(\u0026#34;5-letter-word.json\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: word_list = json.load(f) # word_list = [word for word in word_list if len(word) == 5] # with open(\u0026#34;5-letter-word.json\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: # json.dump(word_list, f) def connect_to_wordle_server(): \u0026#34;\u0026#34;\u0026#34;连接到Wordle服务器\u0026#34;\u0026#34;\u0026#34; host = \u0026#39;challenges.hazmat.buptmerak.cn\u0026#39; port = 21473 sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((host, port)) # 连接到服务器 return sock class WordleSovler(): def __init__(self, all_word): self.all_word = all_word self.possible = all_word self.presence = set() self.presence_letter = set() self.vague = set() self.absence = set() def update_dict(self, guess, feedback): for ind, letter in enumerate(guess): if feedback[ind] == \u0026#34;O\u0026#34;: # print(f\u0026#34;{letter}确定\u0026#34;) self.presence.add((letter,ind)) self.presence_letter.add(letter) elif feedback[ind] == \u0026#34;-\u0026#34;: # print(f\u0026#34;{letter}存在\u0026#34;) self.vague.add((letter,ind)) self.presence_letter.add(letter) elif feedback[ind] == \u0026#34;X\u0026#34; and letter not in self.presence_letter: # print(f\u0026#34;{letter}不存在\u0026#34;) self.absence.add(letter) self.absence_copy = self.absence.copy() for letter in self.absence_copy: if letter in self.presence_letter: self.absence.remove(letter) # print(f\u0026#34;{self.presence=}\u0026#34;) # print(f\u0026#34;{self.vague=}\u0026#34;) # print(f\u0026#34;{self.absence=}\u0026#34;) def is_contain_absence_letters(self, word): for c in word: if c in self.absence: return True return False def is_match_presence(self,word): for letter, index in self.presence: if word[index] != letter: return False return True def is_match_vague(self,word): for letter, index in self.vague: if word[index] == letter or letter not in word: return False return True def update_list(self): new_list = [] for word in self.possible: if self.is_contain_absence_letters(word) or not self.is_match_presence( word) or not self.is_match_vague(word): continue new_list.append(word) self.possible = new_list def get_untried(self,words): counter = Counter() tried = self.absence | self.presence_letter all_letter = set(chr(ord(\u0026#39;a\u0026#39;)+i) for i in range(26)) untried = all_letter - tried for w in words: for c in w: if c in untried: counter[c] += 1 return counter def get_freq(self, words): counter = Counter() for w in words: for c in w: counter[c] += 1 return counter def generator(self, attempt): # self.possible.sort(key=lambda x:-len(set(x))) # return random.choice(self.possible[:50]) untried = self.get_untried(self.possible) freq = self.get_freq(self.possible) if len(untried) \u0026gt; 1 and attempt \u0026lt; 5: word_with_score = [] word_list = self.all_word for word in word_list: letters = set(word) untried_score = sum(untried[c] if c in untried else 0 for c in letters) freq_score = sum(freq[c] if c in freq else 0 for c in letters) word_with_score.append((word,untried_score,freq_score)) ranked_words = sorted(word_with_score, key=lambda item:(-item[1],-item[2],item[0])) guess = ranked_words[0][0] else: guess = \\ sorted(self.possible, key=lambda word: (-len(set(word)), -sum(freq[c] for c in word), word))[0] return guess def update(self, guess, feedback): self.update_dict(guess, feedback) self.update_list() # print(f\u0026#34;after update:{len(self.possible)}\u0026#34;) def reset(self): self.possible = self.all_word self.presence = set() self.presence_letter = set() self.vague = set() self.absence = set() solver = WordleSovler(word_list) def play_one_time(sock:socket, solver:WordleSovler,win): if win == 94: sock.sendall(b\u0026#34;every\u0026#34;) print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # round消息 return True if win == 95: sock.sendall(b\u0026#34;smile\u0026#34;) print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # round消息 return True if win == 96: sock.sendall(b\u0026#34;shows\u0026#34;) print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # round消息 return True if win == 97: sock.sendall(b\u0026#34;great\u0026#34;) print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # round消息 return True if win == 98: sock.sendall(b\u0026#34;power\u0026#34;) print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # round消息 return True attempt = 0 while attempt \u0026lt; 6: print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # round消息 guess = solver.generator(attempt) print(f\u0026#34;try:{guess}\u0026#34;) sock.sendall(guess.encode()) feedback = sock.recv(4096).decode().strip() #XXOO- print(feedback) # print(2) if \u0026#34;OOOOO\u0026#34; in feedback: return True if \u0026#34;You lost.\u0026#34; in feedback: return False if \u0026#34;Word not found!\u0026#34; in feedback: try: solver.all_word.remove(guess) solver.possible.remove(guess) except Exception: pass continue solver.update(guess, feedback) attempt += 1 sock = connect_to_wordle_server() feedback = sock.recv(4096).decode() print(f\u0026#34;初次连接：\\n{feedback}\u0026#34;) win = 0 try: while win \u0026lt; 100: print(f\u0026#34;{win=}\u0026#34;) if play_one_time(sock, solver,win): solver.reset() win += 1 print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # 不要错过flag消息 print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # 不要错过flag消息 print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # 不要错过flag消息 print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # 不要错过flag消息 except Exception as e: print(f\u0026#34;error:{e}\u0026#34;) sock.close() 学习资料 1-4 纯纯工具送分题\n1 内存镜像是 .elf 格式的，看了一下重新下了个volatility3，旧的不支持 用 vol.exe 查看镜像信息即得 2 用 vol.exe -f dump.elf windows.hashdump得到了密码的hash，在线爆破得到密码提交flag\n3 vol.exe -f dump.elf windows.pslist查看进程 4 vol.exe -f dump.elf windows.filescan | findstr 'flag'\n中间因为路径中有 \\u 的干扰，所以在volatility3中的text_render.py的那一块加了个try-expect\n找到flag.txt之后用vol.exe -f dump.elf windows.dumpfile提取得到flag\n学习资料5 流量分析题+一堆乱七八糟的东西 首先搭建一个MC服务器，登录到服务器，想到题干中的还是说......这个世界的**规则**不一样？想到指令\n用 /help 一查看发现有个/decodeblock指令，用这个指令得到了flag.pcapng，但是用wireshark打不开，用winhex查看了文件头不是很常见，（找出题人要了个hint），说要用到java反编译，用jd-gui看到了插件的源码找到了问题所在\n1 2 3 4 for (int i = 0; i \u0026lt; data.length; i++) data[i] = (byte)(data[i] ^ 0xFF); String base64String = Base64.getEncoder().encodeToString(data); return base64String.getBytes(); 写了个脚本复原\n1 2 3 4 5 6 7 8 9 import base64 with open(\u0026#34;flag.pcapng\u0026#34;,\u0026#34;rb\u0026#34;) as f: data = f.read() data = base64.b64decode(data.decode()) new_data = b\u0026#34;\u0026#34; for i in range(len(data)): new_data += (data[i] ^ 0xFF).to_bytes(1,\u0026#34;big\u0026#34;) with open(\u0026#34;flag_decoded.pcapng\u0026#34;,\u0026#34;wb\u0026#34;) as f: f.write(new_data) 发现又打不开，再看发现是zip的文件头，改了后缀，解压发现要密码。刚开始就拉到最下面看了一眼发现了Is password real?的提示，刚开始还傻傻的试了real和real?，后来意识过来时伪加密，把标志位一改就解压出来了。\n用tshark -r flag.pcapng -T field -e usb.capdata \u0026gt;data.txt提取出数据，在wireshark中分析了好久，应该是键盘数据，但是有0104的也有0100的，查了一下0104的是按住了右alt，0100应该就是松开了，自己试着跟着按了一下，发现打出中文字了。去查原理，发现Windows里面Alt+小键盘输入中文字符的gbk编码可以直接输出字符。立马开写脚本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 with open(\u0026#34;usbdata.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: data = f.readlines() data = [i.strip() for i in data if i.strip()] keys = [key[:8] for key in data] vaild_keys = [key[-2:] for key in keys if (key[-2:] != \u0026#34;00\u0026#34; or key[:4] == \u0026#34;0100\u0026#34;) ] # print(keys) print(vaild_keys) mapping = {\u0026#34;59\u0026#34;: \u0026#34;1\u0026#34;,\u0026#34;5a\u0026#34;: \u0026#34;2\u0026#34;,\u0026#34;5b\u0026#34;: \u0026#34;3\u0026#34;,\u0026#34;5c\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;5d\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;5e\u0026#34;: \u0026#34;6\u0026#34;,\u0026#34;5f\u0026#34;: \u0026#34;7\u0026#34;,\u0026#34;60\u0026#34;: \u0026#34;8\u0026#34;,\u0026#34;61\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;62\u0026#34;: \u0026#34;0\u0026#34;} nums = [] num = \u0026#34;\u0026#34; for key in vaild_keys: if key == \u0026#34;00\u0026#34;: if num: nums.append(int(num)) num = \u0026#34;\u0026#34; else: num += mapping[key] print(nums) def gbk_char_from_decimal(decimal_code): gbk_bytes = decimal_code.to_bytes(2, byteorder=\u0026#39;big\u0026#39;) char = gbk_bytes.decode(\u0026#39;gbk\u0026#39;) return char chars = [gbk_char_from_decimal(num) for num in nums] print(chars) with open(\u0026#34;decoded.txt\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: f.write(\u0026#34;\u0026#34;.join(chars)) 得到 熊曰：呋食食出魚常住呱嗡和註誘嗄萌喜圖嗚果哞誘類圖家萌偶物冬噗誘哮洞取啽更雜住嘿嗷有呱性發歡洞捕捕哈洞嘶麼肉家嗥嚄果偶很冬我盜物物嚁囑呦嗄肉笨會告覺哞嗷取呆現喜笨寶噤肉冬\n想起宣讲会上说的，是与熊论道的编码，解了一下码得到U2FsdGVkX18Zz1n2/ZeYSxuFpzOndISllRaiaHVfZ9NZfBC4YbUdCpCttVujDi5r用CyberChefbake了一下发现加盐了（找出题人要了一下hint），在MC的告示牌里得到了密钥是nothing，解密AES得到flag\n熟摩棍哥 读了题目立马想到摩斯电码。刚好整个音频里只有冲和冲刺\n一开始把冲对应的.，发现有一个始终找不到对应，就换了一下冲对应到-就对了。翻译完看到===想到是被编码了，直接CyberChef解决。\nWeb set set what(WEB 签到) 在公告里找到了出题人的QQ，把滑动条的max设置成出题人QQ，直接拉到最后得到了flag\n","date":"2024-09-28T11:12:41+08:00","permalink":"https://XiaoYuan-420.gituhub.io/p/tsctf-j-wp/","title":"TSCTF-J wp"}]